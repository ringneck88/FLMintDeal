{"version":3,"file":"type.js","sources":["../../../../server/src/services/builders/type.ts"],"sourcesContent":["import { isArray, isString, isUndefined, constant } from 'lodash/fp';\nimport { nonNull, list, objectType } from 'nexus';\nimport { contentTypes } from '@strapi/utils';\nimport type { Struct } from '@strapi/types';\n\nimport type { Context } from '../types';\n\nexport type TypeBuildersOptions = {\n  builder: any;\n  attributeName: string;\n  attribute: any;\n  contentType: any;\n  context: Context;\n};\n\nexport default (context: Context) => {\n  const { strapi } = context;\n  const getGraphQLService = strapi.plugin('graphql').service;\n\n  const extension = getGraphQLService('extension');\n\n  /**\n   * Add a scalar attribute to the type definition\n   *\n   * The attribute is added based on a simple association between a Strapi\n   * type and a GraphQL type (the map is defined in `strapiTypeToGraphQLScalar`)\n   */\n  const addScalarAttribute = (options: TypeBuildersOptions) => {\n    const { builder, attributeName, attribute } = options;\n\n    const { mappers } = getGraphQLService('utils');\n\n    const gqlType = mappers.strapiScalarToGraphQLScalar(attribute.type);\n\n    builder.field(attributeName, { type: gqlType });\n  };\n\n  /**\n   * Add a component attribute to the type definition\n   *\n   * The attribute is added by fetching the component's type\n   * name and using it as the attribute's type\n   */\n  const addComponentAttribute = (options: TypeBuildersOptions) => {\n    const { builder, attributeName, contentType, attribute } = options;\n\n    let localBuilder = builder;\n\n    const { naming } = getGraphQLService('utils');\n    const { getContentTypeArgs } = getGraphQLService('builders').utils;\n    const { buildComponentResolver } = getGraphQLService('builders').get('content-api');\n\n    const type = naming.getComponentNameFromAttribute(attribute);\n\n    if (attribute.repeatable) {\n      localBuilder = localBuilder.list;\n    }\n\n    const targetComponent = strapi.getModel(attribute.component);\n\n    const resolve = buildComponentResolver({\n      contentTypeUID: contentType.uid,\n      attributeName,\n      strapi,\n    });\n\n    const args = getContentTypeArgs(targetComponent, {\n      multiple: !!attribute.repeatable,\n      isNested: true,\n    });\n\n    localBuilder.field(attributeName, { type, resolve, args });\n  };\n\n  /**\n   * Add a dynamic zone attribute to the type definition\n   *\n   * The attribute is added by fetching the dynamic zone's\n   * type name and using it as the attribute's type\n   */\n  const addDynamicZoneAttribute = (options: TypeBuildersOptions) => {\n    const { builder, attributeName, contentType } = options;\n\n    const { naming } = getGraphQLService('utils');\n    const { ERROR_CODES } = getGraphQLService('constants');\n    const { buildDynamicZoneResolver } = getGraphQLService('builders').get('content-api');\n\n    const { components } = contentType.attributes[attributeName];\n\n    const isEmpty = components.length === 0;\n    const type = naming.getDynamicZoneName(contentType, attributeName);\n\n    const resolve = isEmpty\n      ? // If the dynamic zone don't have any component, then return an error payload\n        constant({\n          code: ERROR_CODES.emptyDynamicZone,\n          message: `This dynamic zone don't have any component attached to it`,\n        })\n      : //  Else, return a classic dynamic-zone resolver\n        buildDynamicZoneResolver({\n          contentTypeUID: contentType.uid,\n          attributeName,\n        });\n\n    builder.list.field(attributeName, { type, resolve });\n  };\n\n  /**\n   * Add an enum attribute to the type definition\n   *\n   * The attribute is added by fetching the enum's type\n   * name and using it as the attribute's type\n   */\n  const addEnumAttribute = (options: TypeBuildersOptions) => {\n    const { builder, attributeName, contentType } = options;\n\n    const { naming } = getGraphQLService('utils');\n\n    const type = naming.getEnumName(contentType, attributeName);\n\n    builder.field(attributeName, { type });\n  };\n\n  /**\n   * Add a media attribute to the type definition\n   */\n  const addMediaAttribute = (options: TypeBuildersOptions) => {\n    const { naming } = getGraphQLService('utils');\n    const { getContentTypeArgs } = getGraphQLService('builders').utils;\n    const { buildAssociationResolver } = getGraphQLService('builders').get('content-api');\n    const extension = getGraphQLService('extension');\n\n    const { builder } = options;\n    const { attributeName, attribute, contentType } = options;\n    const fileUID = 'plugin::upload.file';\n\n    if (extension.shadowCRUD(fileUID).isDisabled()) {\n      return;\n    }\n\n    const fileContentType = strapi.contentTypes[fileUID];\n\n    const resolve = buildAssociationResolver({\n      contentTypeUID: contentType.uid,\n      attributeName,\n      strapi,\n    });\n\n    const args = attribute.multiple\n      ? getContentTypeArgs(fileContentType, { isNested: true })\n      : undefined;\n\n    const typeName = naming.getTypeName(fileContentType);\n\n    if (attribute.multiple) {\n      builder.field(`${attributeName}_connection`, {\n        type: naming.getRelationResponseCollectionName(fileContentType),\n        resolve,\n        args,\n      });\n\n      builder.field(attributeName, {\n        type: nonNull(list(typeName)),\n        async resolve(...args: unknown[]) {\n          const res = await resolve(...args);\n          return res.nodes ?? [];\n        },\n        args,\n      });\n    } else {\n      builder.field(attributeName, {\n        type: typeName,\n        async resolve(...args: unknown[]) {\n          const res = await resolve(...args);\n          return res.value;\n        },\n        args,\n      });\n    }\n  };\n\n  /**\n   * Add a polymorphic relational attribute to the type definition\n   */\n  const addPolymorphicRelationalAttribute = (options: TypeBuildersOptions) => {\n    const { GENERIC_MORPH_TYPENAME } = getGraphQLService('constants');\n    const { naming } = getGraphQLService('utils');\n    const { buildAssociationResolver } = getGraphQLService('builders').get('content-api');\n\n    let { builder } = options;\n    const { attributeName, attribute, contentType } = options;\n\n    const { target } = attribute;\n    const isToManyRelation = attribute.relation.endsWith('Many');\n\n    if (isToManyRelation) {\n      builder = builder.list;\n    }\n    // todo[v4]: How to handle polymorphic relation w/ entity response collection types?\n    //  -> Currently return raw polymorphic entities\n\n    const resolve = buildAssociationResolver({\n      contentTypeUID: contentType.uid,\n      attributeName,\n      strapi,\n    });\n\n    // If there is no specific target specified, then use the GenericMorph type\n    if (isUndefined(target)) {\n      builder.field(attributeName, {\n        type: GENERIC_MORPH_TYPENAME,\n        resolve,\n      });\n    }\n\n    // If the target is an array of string, resolve the associated morph type and use it\n    else if (isArray(target) && target.every(isString)) {\n      const type = naming.getMorphRelationTypeName(contentType, attributeName);\n\n      builder.field(attributeName, { type, resolve });\n    }\n  };\n\n  /**\n   * Add a regular relational attribute to the type definition\n   */\n  const addRegularRelationalAttribute = (options: TypeBuildersOptions) => {\n    const { naming } = getGraphQLService('utils');\n    const { getContentTypeArgs } = getGraphQLService('builders').utils;\n    const { buildAssociationResolver } = getGraphQLService('builders').get('content-api');\n    const extension = getGraphQLService('extension');\n\n    const { builder } = options;\n    const { attributeName, attribute, contentType } = options;\n\n    if (extension.shadowCRUD(attribute.target).isDisabled()) {\n      return;\n    }\n\n    const isToManyRelation = attribute.relation.endsWith('Many');\n\n    const resolve = buildAssociationResolver({\n      contentTypeUID: contentType.uid,\n      attributeName,\n      strapi,\n    });\n\n    const targetContentType = strapi.getModel(attribute.target);\n\n    const typeName = naming.getTypeName(targetContentType);\n\n    const args = isToManyRelation\n      ? getContentTypeArgs(targetContentType, { isNested: true })\n      : undefined;\n\n    const resolverScope = `${targetContentType.uid}.find`;\n    const resolverPath = `${naming.getTypeName(contentType)}.${attributeName}`;\n\n    extension.use({ resolversConfig: { [resolverPath]: { auth: { scope: [resolverScope] } } } });\n\n    if (isToManyRelation) {\n      builder.field(`${attributeName}_connection`, {\n        type: naming.getRelationResponseCollectionName(targetContentType),\n        resolve,\n        args,\n      });\n\n      extension.use({\n        resolversConfig: { [`${resolverPath}_connection`]: { auth: { scope: [resolverScope] } } },\n      });\n\n      builder.field(attributeName, {\n        type: nonNull(list(typeName)),\n        async resolve(...args: unknown[]) {\n          const res = await resolve(...args);\n          return res.nodes ?? [];\n        },\n        args,\n      });\n    } else {\n      builder.field(attributeName, {\n        type: typeName,\n        async resolve(...args: unknown[]) {\n          const res = await resolve(...args);\n          return res.value;\n        },\n        args,\n      });\n    }\n  };\n\n  const isNotPrivate = (contentType: Struct.Schema) => (attributeName: string) => {\n    return !contentTypes.isPrivateAttribute(contentType, attributeName);\n  };\n\n  const isNotDisabled = (contentType: Struct.Schema) => (attributeName: string) => {\n    return extension.shadowCRUD(contentType.uid).field(attributeName).hasOutputEnabled();\n  };\n\n  return {\n    /**\n     * Create a type definition for a given content type\n     * @param contentType - The content type used to created the definition\n     * @return {NexusObjectTypeDef}\n     */\n    buildTypeDefinition(contentType: Struct.Schema) {\n      const utils = getGraphQLService('utils');\n\n      const { getComponentName, getTypeName } = utils.naming;\n      const {\n        isStrapiScalar,\n        isComponent,\n        isDynamicZone,\n        isEnumeration,\n        isMedia,\n        isMorphRelation,\n        isRelation,\n      } = utils.attributes;\n\n      const { attributes, modelType } = contentType;\n\n      const attributesKey = Object.keys(attributes);\n\n      const name = (modelType === 'component' ? getComponentName : getTypeName).call(\n        null,\n        contentType\n      );\n\n      return objectType({\n        name,\n        definition(t) {\n          // add back the old id attribute on contentType if v4 compat is enabled\n          if (\n            modelType !== 'component' &&\n            isNotDisabled(contentType)('id') &&\n            strapi.plugin('graphql').config('v4CompatibilityMode', false)\n          ) {\n            t.nonNull.id('id', {\n              deprecation: 'Use `documentId` instead',\n            });\n          }\n\n          if (modelType === 'component' && isNotDisabled(contentType)('id')) {\n            t.nonNull.id('id');\n          }\n\n          if (modelType !== 'component' && isNotDisabled(contentType)('documentId')) {\n            t.nonNull.id('documentId');\n          }\n\n          if (strapi.plugin('graphql').config('v4CompatibilityMode', false)) {\n            t.nonNull.field('attributes', {\n              deprecation: 'Use root level fields instead',\n              type: name,\n              resolve: (parent) => parent,\n            });\n\n            t.nonNull.field('data', {\n              deprecation: 'Use root level fields instead',\n              type: name,\n              resolve: (parent) => parent,\n            });\n          }\n\n          /** Attributes\n           *\n           * Attributes can be of 7 different kind:\n           * - Scalar\n           * - Component\n           * - Dynamic Zone\n           * - Enum\n           * - Media\n           * - Polymorphic Relations\n           * - Regular Relations\n           *\n           * Here, we iterate over each non-private attribute\n           * and add it to the type definition based on its type\n           */\n          attributesKey\n            // Ignore private attributes\n            .filter(isNotPrivate(contentType))\n            // Ignore disabled fields (from extension service)\n            .filter(isNotDisabled(contentType))\n            // Add each attribute to the type definition\n            .forEach((attributeName) => {\n              const attribute = attributes[attributeName];\n\n              // We create a copy of the builder (t) to apply custom\n              // rules only on the current attribute (eg: nonNull, list, ...)\n              let builder: any = t;\n\n              if (attribute.required) {\n                builder = builder.nonNull;\n              }\n\n              const options: TypeBuildersOptions = {\n                builder,\n                attributeName,\n                attribute,\n                contentType,\n                context,\n              };\n\n              // Enums\n              if (isEnumeration(attribute)) {\n                addEnumAttribute(options);\n              }\n\n              // Scalars\n              else if (isStrapiScalar(attribute)) {\n                addScalarAttribute(options);\n              }\n\n              // Components\n              else if (isComponent(attribute)) {\n                addComponentAttribute(options);\n              }\n\n              // Dynamic Zones\n              else if (isDynamicZone(attribute)) {\n                addDynamicZoneAttribute(options);\n              }\n\n              // Media\n              else if (isMedia(attribute)) {\n                addMediaAttribute(options);\n              }\n\n              // Polymorphic Relations\n              else if (isMorphRelation(attribute)) {\n                addPolymorphicRelationalAttribute(options);\n              }\n\n              // Regular Relations\n              else if (isRelation(attribute)) {\n                addRegularRelationalAttribute(options);\n              }\n            });\n        },\n      });\n    },\n  };\n};\n"],"names":["context","strapi","getGraphQLService","plugin","service","extension","addScalarAttribute","options","builder","attributeName","attribute","mappers","gqlType","strapiScalarToGraphQLScalar","type","field","addComponentAttribute","contentType","localBuilder","naming","getContentTypeArgs","utils","buildComponentResolver","get","getComponentNameFromAttribute","repeatable","list","targetComponent","getModel","component","resolve","contentTypeUID","uid","args","multiple","isNested","addDynamicZoneAttribute","ERROR_CODES","buildDynamicZoneResolver","components","attributes","isEmpty","length","getDynamicZoneName","constant","code","emptyDynamicZone","message","addEnumAttribute","getEnumName","addMediaAttribute","buildAssociationResolver","fileUID","shadowCRUD","isDisabled","fileContentType","contentTypes","undefined","typeName","getTypeName","getRelationResponseCollectionName","nonNull","res","nodes","value","addPolymorphicRelationalAttribute","GENERIC_MORPH_TYPENAME","target","isToManyRelation","relation","endsWith","isUndefined","isArray","every","isString","getMorphRelationTypeName","addRegularRelationalAttribute","targetContentType","resolverScope","resolverPath","use","resolversConfig","auth","scope","isNotPrivate","isPrivateAttribute","isNotDisabled","hasOutputEnabled","buildTypeDefinition","getComponentName","isStrapiScalar","isComponent","isDynamicZone","isEnumeration","isMedia","isMorphRelation","isRelation","modelType","attributesKey","Object","keys","name","call","objectType","definition","t","config","id","deprecation","parent","filter","forEach","required"],"mappings":"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"}