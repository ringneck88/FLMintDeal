{"version":3,"file":"graphql-filters-to-strapi-query.js","sources":["../../../../../server/src/services/utils/mappers/graphql-filters-to-strapi-query.ts"],"sourcesContent":["import { has, propEq, isNil, isDate, isObject } from 'lodash/fp';\nimport type { Struct } from '@strapi/types';\nimport type { Context } from '../../types';\n\n// todo[v4]: Find a way to get that dynamically\nconst virtualScalarAttributes = ['id', 'documentId'];\n\nexport default ({ strapi }: Context) => {\n  const { service: getService } = strapi.plugin('graphql');\n\n  const recursivelyReplaceScalarOperators = (data: any): any => {\n    const { operators } = getService('builders').filters;\n\n    if (Array.isArray(data)) {\n      return data.map(recursivelyReplaceScalarOperators);\n    }\n\n    // Note: We need to make an exception for date since GraphQL\n    // automatically cast date strings to date instances in args\n    if (isDate(data) || !isObject(data)) {\n      return data;\n    }\n\n    const result: any = {};\n\n    for (const [key, value] of Object.entries(data)) {\n      const isOperator = !!operators[key];\n\n      const newKey = isOperator ? operators[key].strapiOperator : key;\n\n      result[newKey] = recursivelyReplaceScalarOperators(value);\n    }\n\n    return result;\n  };\n\n  return {\n    /**\n     * Transform one or many GraphQL filters object into a valid Strapi query\n     * @param {object | object[]} filters\n     * @param {object} contentType\n     * @return {object | object[]}\n     */\n    graphQLFiltersToStrapiQuery(filters: any, contentType: Struct.Schema): any {\n      const { isStrapiScalar, isMedia, isRelation, isComponent } = getService('utils').attributes;\n      const { operators } = getService('builders').filters;\n\n      const ROOT_LEVEL_OPERATORS = [operators.and, operators.or, operators.not];\n\n      // Handle unwanted scenario where there is no filters defined\n      if (isNil(filters)) {\n        return {};\n      }\n\n      // If filters is a collection, then apply the transformation to every item of the list\n      if (Array.isArray(filters)) {\n        return filters.map((filtersItem) =>\n          this.graphQLFiltersToStrapiQuery(filtersItem, contentType)\n        );\n      }\n\n      const resultMap: any = {};\n      const { attributes } = contentType;\n\n      const isAttribute = (attributeName: string) => {\n        return virtualScalarAttributes.includes(attributeName) || has(attributeName, attributes);\n      };\n\n      for (const [key, value] of Object.entries(filters)) {\n        // If the key is an attribute, update the value\n        if (isAttribute(key)) {\n          const attribute: any = attributes[key];\n\n          // If it's a scalar attribute\n          if (virtualScalarAttributes.includes(key) || isStrapiScalar(attribute)) {\n            // Replace (recursively) every GraphQL scalar operator with the associated Strapi operator\n            resultMap[key] = recursivelyReplaceScalarOperators(value);\n          }\n\n          // If it's a deep filter on a relation\n          else if (isRelation(attribute) || isMedia(attribute)) {\n            // Fetch the model from the relation\n            const relModel = strapi.getModel(attribute.target);\n\n            // Recursively apply the mapping to the value using the fetched model,\n            // and update the value within `resultMap`\n            resultMap[key] = this.graphQLFiltersToStrapiQuery(value, relModel);\n          }\n\n          // If it's a deep filter on a component\n          else if (isComponent(attribute)) {\n            // Fetch the model from the component attribute\n            const componentModel = strapi.getModel(attribute.component);\n\n            // Recursively apply the mapping to the value using the fetched model,\n            // and update the value within `resultMap`\n            resultMap[key] = this.graphQLFiltersToStrapiQuery(value, componentModel);\n          }\n        }\n\n        // Handle the case where the key is not an attribute (operator, ...)\n        else {\n          const rootLevelOperator = ROOT_LEVEL_OPERATORS.find(propEq('fieldName', key));\n\n          // If it's a root level operator (AND, NOT, OR, ...)\n          if (rootLevelOperator) {\n            const { strapiOperator } = rootLevelOperator;\n\n            // Transform the current value recursively and add it to the resultMap\n            // object using the strapiOperator equivalent of the GraphQL key\n            resultMap[strapiOperator] = this.graphQLFiltersToStrapiQuery(value, contentType);\n          }\n        }\n      }\n\n      return resultMap;\n    },\n  };\n};\n"],"names":["virtualScalarAttributes","strapi","service","getService","plugin","recursivelyReplaceScalarOperators","data","operators","filters","Array","isArray","map","isDate","isObject","result","key","value","Object","entries","isOperator","newKey","strapiOperator","graphQLFiltersToStrapiQuery","contentType","isStrapiScalar","isMedia","isRelation","isComponent","attributes","ROOT_LEVEL_OPERATORS","and","or","not","isNil","filtersItem","resultMap","isAttribute","attributeName","includes","has","attribute","relModel","getModel","target","componentModel","component","rootLevelOperator","find","propEq"],"mappings":"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"}